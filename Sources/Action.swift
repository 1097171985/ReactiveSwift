import Dispatch
import Foundation
import enum Result.NoError

/// Represents an action that will do some work when executed with a value of
/// type `Input`, then return zero or more values of type `Output` and/or fail
/// with an error of type `Error`. If no failure should be possible, NoError can
/// be specified for the `Error` parameter.
///
/// Actions enforce serial execution. Any attempt to execute an action multiple
/// times concurrently will return an error.
public final class Action<Input, Output, Error: Swift.Error> {
	private let deinitToken: Lifetime.Token?
	private let executeClosure: (Input) -> SignalProducer<Output, Error>
	private let eventsObserver: Signal<Event<Output, Error>, NoError>.Observer
	private let disabledErrorsObserver: Signal<(), NoError>.Observer
	private let producerFactory: (Input) -> SignalProducer<Output, ActionError<Error>>

	/// The lifetime of the Action.
	public let lifetime: Lifetime

	/// A signal of all events generated from applications of the Action.
	///
	/// In other words, this will send every `Event` from every signal generated
	/// by each SignalProducer returned from apply() except `ActionError.disabled`.
	public let events: Signal<Event<Output, Error>, NoError>

	/// A signal of all values generated from applications of the Action.
	///
	/// In other words, this will send every value from every signal generated
	/// by each SignalProducer returned from apply() except `ActionError.disabled`.
	public let values: Signal<Output, NoError>

	/// A signal of all errors generated from applications of the Action.
	///
	/// In other words, this will send errors from every signal generated by
	/// each SignalProducer returned from apply() except `ActionError.disabled`.
	public let errors: Signal<Error, NoError>

	/// A signal which is triggered by `ActionError.disabled`.
	public let disabledErrors: Signal<(), NoError>

	/// Whether the action is currently executing.
	public let isExecuting: Property<Bool>

	private let _isExecuting: MutableProperty<Bool> = MutableProperty(false)

	/// Whether the action is currently enabled.
	public var isEnabled: Property<Bool>

	private let _isEnabled: MutableProperty<Bool> = MutableProperty(false)

	/// Whether the instantiator of this action wants it to be enabled.
	private let isUserEnabled: Property<Bool>

	/// This queue is used for read-modify-write operations on the `_executing`
	/// property.
	private let executingQueue = DispatchQueue(
		label: "org.reactivecocoa.ReactiveSwift.Action.executingQueue",
		attributes: []
	)

	/// Whether the action should be enabled for the given combination of user
	/// enabledness and executing status.
	private static func shouldBeEnabled(userEnabled: Bool, executing: Bool) -> Bool {
		return userEnabled && !executing
	}

	/// Initializes an action that will be conditionally enabled, and creates a
	/// SignalProducer for each input.
	///
	/// - parameters:
	///   - lifetime:
	///   - enabledIf: Boolean property that shows whether the action is
	///                enabled.
	///   - execute: A closure that returns the signal producer returned by
	///              calling `apply(Input)` on the action.
	private init<P: PropertyProtocol>(lifetime: Lifetime, token: Lifetime.Token?, enabledIf property: P, _ execute: @escaping (Input) -> SignalProducer<Output, Error>) where P.Value == Bool {
		self.lifetime = lifetime
		deinitToken = token

		executeClosure = execute
		isUserEnabled = Property(property)

		(events, eventsObserver) = Signal<Event<Output, Error>, NoError>.pipe()
		(disabledErrors, disabledErrorsObserver) = Signal<(), NoError>.pipe()

		lifetime.ended.observeCompleted(eventsObserver.sendCompleted)
		lifetime.ended.observeCompleted(disabledErrorsObserver.sendCompleted)

		values = events.map { $0.value }.skipNil()
		errors = events.map { $0.error }.skipNil()

		isEnabled = _isEnabled.take(during: lifetime)
		isExecuting = _isExecuting.take(during: lifetime)

		_isEnabled <~ property.producer
			.combineLatest(with: isExecuting.producer)
			.map(Action.shouldBeEnabled)

		producerFactory = { [executingQueue, _isEnabled, _isExecuting, disabledErrorsObserver, eventsObserver, executeClosure] input in
			return SignalProducer { observer, disposable in
				var startedExecuting = false

				executingQueue.sync {
					if _isEnabled.value {
						_isExecuting.value = true
						startedExecuting = true
					}
				}

				if !startedExecuting {
					observer.send(error: .disabled)
					disabledErrorsObserver.send(value: ())
					return
				}

				executeClosure(input).startWithSignal { signal, signalDisposable in
					disposable += signalDisposable

					signal.observe { event in
						observer.action(event.mapError(ActionError.producerFailed))
						eventsObserver.send(value: event)
					}
				}

				disposable += {
					_isExecuting.value = false
				}
			}
		}
	}

	/// Initializes an action that will be conditionally enabled, and creates a
	/// SignalProducer for each input.
	///
	/// - parameters:
	///   - enabledIf: Boolean property that shows whether the action is
	///                enabled.
	///   - execute: A closure that returns the signal producer returned by
	///              calling `apply(Input)` on the action.
	public convenience init<P: PropertyProtocol>(enabledIf property: P, _ execute: @escaping (Input) -> SignalProducer<Output, Error>) where P.Value == Bool {
		let token = Lifetime.Token()
		let lifetime = Lifetime(token)
		self.init(lifetime: lifetime, token: token, enabledIf: property, execute)
	}

	/// Initializes an action that will be conditionally enabled, and creates a
	/// SignalProducer for each input.
	///
	/// - parameters:
	///   - enabledIf: Boolean property that shows whether the action is
	///                enabled.
	///   - execute: A closure that returns the signal producer returned by
	///              calling `apply(Input)` on the action.
	public convenience init<P: PropertyProtocol>(lifetime: Lifetime, enabledIf property: P, _ execute: @escaping (Input) -> SignalProducer<Output, Error>) where P.Value == Bool {
		self.init(lifetime: lifetime, token: nil, enabledIf: property, execute)
	}

	/// Initializes an action that will be enabled by default, and creates a
	/// SignalProducer for each input.
	///
	/// - parameters:
	///   - execute: A closure that returns the signal producer returned by
	///              calling `apply(Input)` on the action.
	public convenience init(_ execute: @escaping (Input) -> SignalProducer<Output, Error>) {
		self.init(enabledIf: Property(value: true), execute)
	}

	/// Initializes an action that will be enabled by default, and creates a
	/// SignalProducer for each input.
	///
	/// - parameters:
	///   - execute: A closure that returns the signal producer returned by
	///              calling `apply(Input)` on the action.
	public convenience init(lifetime: Lifetime, _ execute: @escaping (Input) -> SignalProducer<Output, Error>) {
		self.init(lifetime: lifetime, enabledIf: Property(value: true), execute)
	}

	/// Creates a SignalProducer that, when started, will execute the action
	/// with the given input, then forward the results upon the produced Signal.
	///
	/// - note: If the action is disabled when the returned SignalProducer is
	///         started, the produced signal will send `ActionError.disabled`,
	///         and nothing will be sent upon `values` or `errors` for that
	///         particular signal.
	///
	/// - parameters:
	///   - input: A value that will be passed to the closure creating the signal
	///            producer.
	public func apply(_ input: Input) -> SignalProducer<Output, ActionError<Error>> {
		return producerFactory(input)
	}

	/// Binds a signal to an action, executing the action with the latest
	/// value sent by the signal.
	///
	/// - note: The binding will automatically terminate when the lifetime of the
	///         target is deinitialized, or when the signal sends a `completed`
	///         event.
	///
	/// - parameters:
	///   - target: An action to be bond to.
	///   - signal: A signal to bind.
	///
	/// - returns: A disposable that can be used to terminate binding before the
	///            end of lifetime of the action or the signal's `completed`
	///            event.
	@discardableResult
	public static func <~ <Source: SignalProtocol>(target: Action, signal: Source) -> Disposable? where Source.Value == Input, Source.Error == NoError {
		return signal
			.take(during: target.lifetime)
			.observeValues { [producerFactory = target.producerFactory] value in
				producerFactory(value).start()
			}
	}
}

public protocol ActionProtocol: BindingTargetProtocol {
	/// The type of argument to apply the action to.
	associatedtype Input
	/// The type of values returned by the action.
	associatedtype Output
	/// The type of error when the action fails. If errors aren't possible then
	/// `NoError` can be used.
	associatedtype Error: Swift.Error

	/// Whether the action is currently enabled.
	var isEnabled: Property<Bool> { get }

	/// Extracts an action from the receiver.
	var action: Action<Input, Output, Error> { get }

	/// Creates a SignalProducer that, when started, will execute the action
	/// with the given input, then forward the results upon the produced Signal.
	///
	/// - note: If the action is disabled when the returned SignalProducer is
	///         started, the produced signal will send `ActionError.disabled`,
	///         and nothing will be sent upon `values` or `errors` for that
	///         particular signal.
	///
	/// - parameters:
	///   - input: A value that will be passed to the closure creating the signal
	///            producer.
	func apply(_ input: Input) -> SignalProducer<Output, ActionError<Error>>
}

extension ActionProtocol {
	public func consume(_ value: Input) {
		apply(value).start()
	}
}

extension Action: ActionProtocol {
	public var action: Action {
		return self
	}
}

/// The type of error that can occur from Action.apply, where `Error` is the
/// type of error that can be generated by the specific Action instance.
public enum ActionError<Error: Swift.Error>: Swift.Error {
	/// The producer returned from apply() was started while the Action was
	/// disabled.
	case disabled

	/// The producer returned from apply() sent the given error.
	case producerFailed(Error)
}

public func == <Error: Equatable>(lhs: ActionError<Error>, rhs: ActionError<Error>) -> Bool {
	switch (lhs, rhs) {
	case (.disabled, .disabled):
		return true

	case let (.producerFailed(left), .producerFailed(right)):
		return left == right

	default:
		return false
	}
}
